- 오늘은 실제로 library interpositioning을 구현하는 방법에 대해서 실습해보겠습니다.
- library interpositioning은 수업 때 배우신 것처럼 임의의 library 함수 실행 시에 함수 호출을 가로채라는 명령어를 실행할 수 있게 하는 기술입니다.
- library interpositioning의 개념과 종류 등은 수업 시간에 배우셨기에 넘어갈게요
- 12쪽부터 시작하겠습니다.
- 오늘부터 2주가 구현하게 될 것은 동적 메모리 할당을 runtime library interpositioning을 사용하여 tracing하는 방법입니다.
- 즉 얼만큼의 공간을 할당 요청했는지, 결과로 받은 메모리 주소는 무엇인지 등을 출력하는 프로그램을 구현하게 될 것입니다.
- 초기 설정은 파트0을 참조하시면 됩니다.
- 과제는 part1~3이 각각 30점, 레포트가 10점. 총 100점
- 제출은 3월 31일 수요일 오후 23시 59분까지 제출.
- 제출은 etl에 업로드. 구현한 코드와 레포트 pdf로 압축해서 tar 파일로 제출.
- 레포트와 압축 파일 제목은 lab-학번.tar/pdf로.
- 다음 페이지는 tracing할 대상은 동적 메모리 할당 함수들에 대한 설명.
- 함수는 malloc, calloc, realloc, free.
  - malloc은 메모리 할당하여 그 시작 주소를 반환하는 함수.
  - calloc은 사이즈 크기의 entry를 nmemb개 만큼의 배열을 할당하여 그 시작주소를 반환하는 함수.
  - realloc은 포인터의 위치에 이미 할당된 메모리를 반환하며 사이즈 크기의 새로운 공간을 할당하여 그 시작 주소를 반환. 이 때, 포인터 위치의 공간에 들어있는 데이터는, 새로운 공간으로 복사됨. 재할당 전의 공간이 더 클 경우 시작 위치에서부터 새로운 크기 만큼만 복사. 자세한 사항은 realloc 매뉴얼 페이지 참조.
  - free는 포인터 주소에 있는 할당된 메모리들을 할당 해제하는 함수. 
- 14페이지부터는 동적 메모리 함수들의 사용 예시.
- 15쪽은 shared library를 loading하는 함수들. 
  - dlopen은 공유 라이브러리 파일 이름을 로드하고 링크하는 함수.
  - dlsym은 dlopen 함수를 통해 얻은 handle과 symbol 이름을 받고 symbol 주소를 리턴.
  - dlclose는 dlopen한 파일을 닫는 함수.
  - 추가로 dlerror라는 뒤의 세 가지 함수를 호출한 결과로 가장 최근에 발생한 에러를 string으로 반환하는 함수. 자세한 내용은 매뉴얼 페이지 참고.
- 16쪽은 설치 방법.
- 17페이지. part1은 동적 메모리 할당을 tracing. 
  - tracing 대상은 할당 크기, 할당 받은 주소, 할당 해제한 주소.
  - 할당 받은 전체 크기와 평균 할당 크기를 구해서 출력.
  - 전체 할당 해제 크기는 추적 x, freed_total은 0으로 남겨요.
  - `util/memlog.h`에 결과 출력하는 매크로 있으니 활용하세요.
  - 주의할 점은, realloc으로 재할당 받는 경우 원래 할당받은 메모리 사이즈를 빼지 않고 모두 더하기만 하면 된다.
- 18페이지는 테스트 코드와 그 결과.
  - 미리 작성된 매크로로 결과 출력하면 되고 아래 사진 statistics 부분처럼 할당 크기 합과 평균 구하면 됨.  
- 19페이지부터는 part2에 대한 설명.
  - part2에서는 part1에서 작성한 memtrace.c를 part2 디렉터리로 복사한 후 그 파일을 수정하면 됨.
  - part1에서 추가로 tracing할 것은 전체 해제된 메모리 크기와 할당 해제하지 않은 메모리 공간.
  - 이것을 위해서 할당한 메모리 공간에 대한 데이터를 따로 관리를 해야함.
  - linked list로 관리하면 되고 관련 함수는 `memlist.c`, `memlist.h` 파일에 준비했으니 사용하세요.
  - 준비한 함수를 사용하지 않고 직접 linked list 구현해서 사용해도 무방. 
  - 주의할 점은, realloc도 free처럼 할당을 해제하는 부분이 있기 때문에 realloc시에 할당 해제된 만큼 전체 할당 해제 크기, 즉 freed total에 더해주고, 할당된 block list도 적절히 관리해야함.
- 20페이지는 part2의 결과 예시. 
  - 첫번째 네모 칸처럼 할당 해제된 크기 프린트.
  - 그 밑에 할당되었으나 해제되지 않은 블락 출력.
  - 다만 모든 블락이 해제된 경우 21페이지 그림처럼 이 부분을 보여주지 않도록 구현해야함.
- 22페이지부터는 part3 관련 설명.
  - part2에서 만든 파일을 part3로 복사해서 구현.
  - illegal free와 double free를 찾고 그로 인해 발생하는 에러를 무시하는 작업.
  - illegal free는 할당되지 않은 메모리를 할당해제하려고 하는 것.
  - double free는 이미 free한 메모리를 다시 free하려고 하는 것.
  - part2와 마찬가지로 realloc에도 구현해야 함.
  - illegal free와 double free의 경우 프로세스가 죽게 되는데 프로세스가 죽지 않도록 처리 해줘야 함.
- 23페이지는 part3의 결과 예시.
  - 네모 칸처럼 double free랑 illegal free가 있다는걸 출력해주고
  - 에러가 나지 않고 process가 정상 종료 되도록 구현.
- 24페이지는 스켈레톤 코드에 대한 설명.
  - 스켈레톤 코드에는 init과 fini라는 함수들이 있음.
  - init처럼 `constructor` attribute가 붙은 함수는 프로그램이 시작되면서나 또는 shared library가 로딩되면서 바로 호출되는 함수.
  - 즉 자바를 예로 들면 생성자라고 보면 됨.
  - 반대로 fini처럼 `destructor` attribute가 붙은 함수는 프로그램이 종료될 때 또는 dlclose될 때 호출되는 함수. 일종의 소멸자.
- 25페이지는 utility 함수들. 각각의 `c`와 header file을 잘 보고 활용하세요.
- 26페이지에 나온 것처럼 레포트 작성해주세요.
- 27-28페이지.
  - printf error --> `fprintf` or `mlog` 사용
  - test 폴더의 testx는 사용 x
  - part1, 2는 test4 실행했을 때 에러메세지 나오는 것이 정상
