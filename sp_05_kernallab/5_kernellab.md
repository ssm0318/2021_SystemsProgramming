- 2페이지를 보시면 제출 형식, 마감 등. 양식은 이전과 동일하게. 제출 마감은 3주 뒤인 6월 2일 수요일 23시 59분.
- 주의할 점은 이번 과제는 루트 권한이 필요하기 때문에 서버 머신을 사용하지 않고 개인 vm을 사용하셔야 함.
- 이번에 제출한 리포트에 대해서는 과제 스펙 문서에 설명되어 있으니 참고.
- 커널랩은 파트1과 2로 나뉘는데, 1에서는 pid를 인풋으로 받아 프로세스 트리를 출력, 파트2에서는 가상주소를 가지고 물리주소를 찾는 프로그램 작성.
- 과제 설명에 앞서 4쪽부터는 커널 프로그래밍에 대해 설명.
- 커널은 간단히 말해 os의 핵심적인 부분.
- 커널 프로그래밍은 스케줄링, 캐시 교체 정책, 파일 시스템 등의 변경, 또는 커널의 정보를 알고 싶을 때 하게 됨.
- 커널을 변경하기 위해서는 커널 소스를 변경하고 컴파일해야함.
- 하지만 이런 방식은 너무 어렵고 컴파일에 많은 시간 소요. 
- 그래서 보다 간단한 방법으로 커널 모듈을 만드는 방법이 있으며 이것을 이번 실습에서 이용하게 됨. 
- 6페이지부터는 kernel module에 대한 설명. 커널 모듈은 필요에 따라 커널을 로드, 언로드를 할 수 있는 코드.
- 커널 모듈을 사용해서 시스템콜 없이 privileged instruction을 사용할 수 있습니다. 
- 커널 모듈에는 일반적으로 gcc 명령으로는 컴파일이 되지 않으며 특별한 명령을 사용해야 하는데요, 슬라이드 하단에는 모듈을 load, unload하는 커맨드가 나와있음.
- 7쪽은 kernel 모듈의 컨벤션. 일반적으로 커널 모듈은 7쪽에 나와있는 것과 같은 함수를 사용. 이에 대한 설명은 다음 페이지에 있으니 읽어보셈.
- 9페이지는 커널 컴파일에 대한 예시. 과제에서도 이와 같은 구조의 makefile을 사용해서 컴파일하게 됨.
- 10장에서는 이 makefile을 사용한 옵션 등에 대해 설명되어 있음.
- 이번 과제와는 크게 상관 없지만 혹시 궁금한 분들은 읽어보셈.
- 11페이지. 앞서 설명한 커널 프로그래밍을 해도 유저가 이걸 사용하기 위해서는 유저와 커널 간의 인터페이스가 필요.
- 이 인터페이스를 만들기 위해서는 이번 랩에서는 디버그 시스템을 사용하게 되는데, 
- 디버거 파일 시스템 debug fs는 특별한 파일 시스템 종류 중 하나로 원래 디버깅 목적으로 설계. 
- 디버그 fs는 커널 개발자가 커널의 정보를 유저에게 간단하게 전달하기 위해 사용.
- 13쪽에는 디버기 fs의 api가 나와있음. 이 api를 이용하여 디버그 fs 상에 디렉토리를 생성 삭제할 수 있음
- 여기서 함수를 잘 보면 d entry나 file operations라는 처음 보는 구조체가 있음.
- d entry는 디렉토리 엔트리. 파일이나 디렉토리 나타냄.
- file operation 구조체는 파일 함수 포인트에 대한 구조체. 이것은 device driver나 디버그 fs내의 파일과 통신하기 위해 사용.
- 사용할때는 15쪽의 코드와 같이 작성한 함수를 파일 오퍼레이션에 매핑하면 됨.
- 예를 들어 file read라는 함수를 read operation에 매핑한 경우 디버그 파일 시스템 상의 파일을 읽으려는 시도를 할 경우 file read라는 함수가 실행되는 식으로 동작하게 됨.
- 16쪽부터 이어서 설명. 구현을 시작하기에 앞서 이 페이지 스크린샷과 같이 ptree나 paddress 디렉토리에서 sudo 권한으로 make, make clean을 실행하기 바람. 정상적으로 된 경우 d message 명령을 입력하면 module initialize done이나 module exit이라는 출력을 볼 수 있을 것.
- 참고로 lsb release 그 a 옵션을 주는 것은 우분투 버전을 uname하고 r 옵션을 주는 것은 이제 커널 버전을 출력해주게 됨.
- 스크린샷에서 출력된 버전은 저희가 실습에서 사용하는 버전과 다르기 때문에 이 부분이 다르게 출력되는 것은 신경쓰지 않으셔도 됨.
- 이 과정은 과제 스펙 문서 4.1에 설명되어 있으니 참고. 이 부분은 리포트에 스크린샷 붙여서 제출 바람.
- 18페이지부터는 과제 1에 대해 설명. 
- 파트1은 pid 값을 받아서 1번 프로세스, 즉 init process로부터 입력으로 받은 프로세스까지 프로세스 path를 출력하는 프로그램을 작성하는 것. 
- 테스트는 19페이지에 나온 바와 같이 하면 됨. 우선 root로 접속해서 debug fs의 root directory, 즉 root 아래에 sys kernel debug 디렉토리로 갑니다.
- 그 이후 ptree 디렉토리로 가서 ps 명령어를 실행해서 pid를 얻고요 이 pid를 echo 명령어로 input file에 write합니다.
- 그 후 cat 명령어로 ptree를 읽으면 됨.
- 20페이지는 skeleton code에 대한 설명. 
- 중간에 보이는 input d를 에 ? 인풋으로 읽으려는 파일을 디버그 fs api를 사용해서 작성해주시고 ptree dir에 output 파일을 쓰려는 파일을 마찬가지로 작성.
- input dir같은 경우 debug fs, create file을 사용하시면 되는데 ptree dir같은 경우 api 문서를 보시고 적절한 함수를 찾아서 사용하셔야 됨.
- 21페이지입니다. 아래에 보시면 file operation 구조체에 write operation에 대한 함수는 이미 매핑되어 있는데, 매핑된 함수는 write pid to input이라는 함수로 skeleton code가 나와있으니 여기 적절하게 구현하시면 됩니다.
- 22페이지부터는 part2에 대한 설명. part2에서는 page table ?를 하여 가상주소를 물리주소로 바꾸는 프로그램을 작성하게 됨. 
- 이 변환과정은 수업 시간에 배우셨을테니 생략.
- 25페이지를 보시면 p address 디렉토리는 app.c 파일과 debug fs, paddress.c, paddr.c 파일이 있습니다.
- 이 중 app.c 파일은 가상주소르 물리주소로 매핑하는 역할을 하며, 여러분이 작성한 코드의 리턴값과 실제 물리주소를 비교해서 정답인지 아닌지를 체크.
- 이 app.c 파일은 변경하면 안되고 구현은 debug_paddress.c 파일에 하시면 됨.
- debug_paddress.c에는 앱에서 pid와 가상주소를 받아서 물리주소를 리턴하는 동작을 구현하면 됨.
- 26페이지에 part2에 대한 힌트가 있음. page table work entry 같은 경우 26페이지에 나와있은 헤더 파일에서 확인 가능.
- 저희가 사용하는 리눅스 버전에서는 5개 레벨의 페이지 table을 사용하고 있음.
- 27페이지에서는 여러분이 작성한 코드를 테스트하는 방법.
- sudo 권한 획득 후 make를 하신 다음에 app을 실행시켜서 테스트가 통과됐는지 확인하시면 됨.
- 28쪽에서는 part1, 2에서 사용하는 커널 함수와 자료구조가 나와있음.
- test soft는 process의 정보를 확인하기 위해 봐야할 구조체. list ? 는 list를 관리하기 위한 것으로 process tree 검색 시 도움이 되니 참고 바람.
- kernel code는 kernel code를 직접 다운로드 받거나 부틀린?이라는 사이트에서 확인할 수 있음
- 커널 디버깅은 일반적인 응용의 디버깅보다 어려움. 일반적인 gdb는 사용할 수 없고 또한 printf 등의 함수로 출력할 수도 없음.
- 커널에서는 그래서 printk를 이용해서 커널에 로그를 남기는데 이걸 이용해서 디버깅 가능.
- d message라는 명령어 사용하면 커널 로그 볼 수 있으며 w옵션을 주어서 계속 로그 창 띄워놓고 확인하면서 프로그래밍 가능.
- 31페이지부터는 커널 프로그래밍에 도움이 되는 도구를 설명. 
- 우선 tmux?는 한 터미널 창을 여러개로 분할하는 등의 기능을 함. 또한 c tax?하고 c scope 명령어로 커널 소스에서 원하는 소스가 어디에 정의되어 있는지를 찾아볼 수 있음. 
- 설치 방법과 사용 방법은 뒤의 슬라이드를 참고.
- 44페이지를 보시면 faq 파트1, 2가 나와있는데요 자주 나오는 질문들이 있으니 확인하시고 구현 시작하시면 될 것 같다.